import java.util.Queue;
import java.util.LinkedList;

//resolution
int ball_number = 5;
int ball_circle = 10;
int tube_number = 25;
int tube_circle = 7;

//ball radius = the radius of the circumcircle of first triangle + test_radius
float test_radius = 25;
float ball_radius;
pt absolute_center;


ArrayList<Triangle> final_triangle = new ArrayList<Triangle> (); // Triangles Generated by Ball Pivoting
ArrayList<pt> test_vertex = new ArrayList<pt>(); // Used for ball pivotingtest

ArrayList<Edge> visited_edge = new ArrayList<Edge>(); // Record the edges which have been visited
Queue<Triangle> pendingTriangles = new LinkedList<Triangle>(); // Store the triangles which haven't been dealt with

void BallPivot_Clear()
{
  vertices.clear();
  final_triangle.clear();
  test_vertex.clear();
  visited_edge.clear();
}
void BallPivot_Init()
{
  // First Triangle to be 'Ball pivot'
  if (choice == 4)
    pendingTriangles.offer(firstTri);
  // Used for ballpivoting test
  if (choice == 5)
  {
    for (int i = 0; i < P.nv; i++)
      test_vertex.add(P.G[i]);

    for (int i = 0; i < Q.nv; i++)
      test_vertex.add(Q.G[i]);

    Triangle temp_triangle = new Triangle(Q.G[0], Q.G[1], Q.G[2]);
    vec AB = V(Q.G[0], Q.G[1]);
    vec AC = V(Q.G[0], Q.G[2]);

    temp_triangle.normal = U(cross(AB, AC));
    final_triangle.add(temp_triangle);

    pendingTriangles.offer(temp_triangle);
  }


  size_record = 1;
  count = 0;

  //radius of ball;
  ball_radius = CircleTri_radius(pendingTriangles.element());
  if (choice == 5)
    ball_radius += 2000;
  else
    ball_radius += test_radius;

  // used for deciding the correct normal vector(test only)
  absolute_center = CircleTri(pendingTriangles.element());
  absolute_center.z = (h_ceiling + h_floor) / 2.0f;
}
void BallPivot(ArrayList<pt> vertex)
{
  // Use ball pivoting algorithm gradually
  while (pendingTriangles.size() > 0 && count < size_record)
  {

    Triangle temp_tri = pendingTriangles.poll();
    final_triangle.add(temp_tri);

    Edge AB = new Edge(temp_tri.a, temp_tri.b);
    Edge BC = new Edge(temp_tri.b, temp_tri.c);
    Edge AC = new Edge(temp_tri.a, temp_tri.c);

    if (!inEdgeBuffer(visited_edge, AB))
      NextTriangle(temp_tri, AB, temp_tri.c, vertex, ball_radius, absolute_center,temp_tri.ai,temp_tri.bi);

    if (!inEdgeBuffer(visited_edge, BC))
      NextTriangle(temp_tri, BC, temp_tri.a, vertex, ball_radius, absolute_center,temp_tri.bi,temp_tri.ci);

    if (!inEdgeBuffer(visited_edge, AC))
      NextTriangle(temp_tri, AC, temp_tri.b, vertex, ball_radius, absolute_center,temp_tri.ai,temp_tri.ci);

    if (choice == 4)
      count++;
  }
  if (count >= size_record)
  {
    size_record = pendingTriangles.size();
    count = 0;
  }
  //Construct triangle mesh: Completed
  if (pendingTriangles.size() <= 0)
  {
    complete_flag = true;
  }
}

void Render_BallPivot()
{
  for (int i = 0; i < final_triangle.size(); i++)
  {
    RenderTriangle(final_triangle.get(i));
  }
}

// Rotate the ball to next vertex . tri : the original triangle, e : the rotate axis(an edge of the triangle),third_vertex: tri - e, vertex: the vertices array, radius : radius of the ball, abscenter: haven't been used now
void NextTriangle(Triangle tri, Edge e, pt third_vertex, ArrayList<pt> vertex, float radius, pt abscenter,int ai_,int bi_)
{
  pt circle_center = CircleTri(tri);

  vec outside_vector;
  if (choice == 5)
    outside_vector = V(abscenter, circle_center);
  else
    outside_vector = tri.normal;

  pt center = SphereCenter(tri, radius, outside_vector);
  
  // min rotation angle of the ball and the record for the vertex index
  float min_angle =  2 * PI + 1;
  int record = -1;

  for (int i = 0; i < vertex.size(); i++)
  {
    //next point
    pt np = vertex.get(i);

    //This point is the vertex of the triangle,skip it
    if (IsTriangleVertex(tri, np))
      continue;
      
    // if the radius of the triangle is larger the sphere radius, skip it
    Triangle test_tri = new Triangle(e.a, e.b, np);
    float test_radius = CircleTri_radius(test_tri);
    
    if (test_radius > radius)
      continue;

    pt temp_circlecenter = CircleTri(test_tri);
    vec outside_vector2;
    if (choice == 5)
      outside_vector2 = V(abscenter, temp_circlecenter);
    else
      outside_vector2 = Triangle_normal(ai_,bi_,i);

    //cirlce of a triangle with the edge and the new point
    pt np_center = SphereCenter(e.a, e.b, np, radius, outside_vector2);
    pt edge_mid = P(e.a, e.b);
    vec v1 = V(edge_mid, center);
    vec v2 = V(edge_mid, np_center);
    vec v3 = V(edge_mid, third_vertex);
    vec rotate_dir = U(cross(v3, v1));
    vec test_dir =  U(cross(v1, v2));
    
    float angle_helprer = dot(rotate_dir, test_dir);
    float rotate_angle = angle(v1, v2);

    //Because angle() return 0 - PI,so it needs to be changed into 0 - 2 * PI for this project
    if (angle_helprer < 0.001f)
      rotate_angle = 2 * PI - rotate_angle;

    if (rotate_angle < min_angle)
    {
      min_angle = rotate_angle;
      record = i;
    }
  }

  if (record != -1)
  {
    visited_edge.add(e);
    Edge e1 = new Edge(e.a, vertex.get(record));
    Edge e2 = new Edge(e.b, vertex.get(record));
    Triangle temp_tri = new Triangle(e.a, e.b, vertex.get(record));

    if (choice == 4)
    {
      temp_tri.normal = Triangle_normal(ai_,bi_,record);
      temp_tri.ai = ai_;
      temp_tri.bi = bi_;
      temp_tri.ci = record;
    }
      

    //if e1 or e2 hasn't been visited,the triangle is useful for ball pivoting.Otherwise,we just add it to final_triangle. 
    if (!inEdgeBuffer(visited_edge, e1) || !inEdgeBuffer(visited_edge, e2))
    {
      pendingTriangles.offer(temp_tri);
    } else
    {
      final_triangle.add(temp_tri);
    }
  }
}
//Test if the edge is in the edge buffer
boolean inEdgeBuffer(ArrayList<Edge> ebuffer, Edge e)
{
  boolean findflag = false;
  for (int i = 0; i < ebuffer.size(); i++)
  {
    if (SameEdge3D(ebuffer.get(i), e))
    {
      findflag = true;
      break;
    }
  }
  if (!findflag)
  {
    return false;
  } else
  {
    return true;
  }
}
boolean IsTriangleVertex(Triangle tri, pt vertex)
{
  float deviation = 0.001f;
  if (abs(tri.a.x - vertex.x) < deviation && abs(tri.a.y - vertex.y) < deviation && abs(tri.a.z - vertex.z) < deviation)
    return true;
  else if (abs(tri.b.x - vertex.x) < deviation && abs(tri.b.y - vertex.y) < deviation && abs(tri.b.z - vertex.z) < deviation)
    return true;
  else  if (abs(tri.c.x - vertex.x) < deviation && abs(tri.c.y - vertex.y) < deviation && abs(tri.c.z - vertex.z) < deviation)
    return true;

  return false;
}

void RenderTriangle(Triangle tri)
{
  beginShape();
  //   normal(normals.get(i).get(j));
  vertex(tri.a);

  //   normal(normals.get(i).get(next_j));
  vertex(tri.b);

  //   normal(normals.get(i + 1).get(next_j));
  vertex(tri.c);

  endShape();
}

void buffer_reset()
{
  vertices.clear();
  pendingTriangles.clear();
  complete_flag = false;
}


vec Triangle_normal(int ai,int bi,int ci)
{
  vec vecNormal = new vec();
  
  vec dir = vertex_dir.get(ci);
  pt A = vertices.get(ai);
  pt B = vertices.get(bi);
  pt C = vertices.get(ci);
  
  vec AB = V(A,B);
  vec AC = V(A,C);
  
  vecNormal = U(cross(AB,AC));
  if(dot(vecNormal,dir) < 0)
  {
    vecNormal = V(-1,vecNormal);
  }
  return vecNormal;
}