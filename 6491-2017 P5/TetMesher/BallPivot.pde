import java.util.Queue;
import java.util.LinkedList;

//resolution
int ball_number = 5;
int ball_circle = 10;
int tube_number = 25;
int tube_circle = 7;

//ball radius = the radius of the circumcircle of first triangle + test_radius
float test_radius = 20;
float ball_radius;
pt absolute_center;


ArrayList<Triangle> final_triangle = new ArrayList<Triangle> (); // Triangles Generated by Ball Pivoting
ArrayList<pt> test_vertex = new ArrayList<pt>(); // Used for ball pivotingtest

ArrayList<Edge> visited_edge = new ArrayList<Edge>(); // Record the edges which have been visited
Queue<Triangle> pendingTriangles = new LinkedList<Triangle>(); // Store the triangles which haven't been dealt with

void BallPivot_Clear()
{
  vertices.clear();
  final_triangle.clear();
  test_vertex.clear();
  visited_edge.clear();
}
void BallPivot_Init()
{
  // First Triangle to be 'Ball pivot'
  if (choice == 4)
    pendingTriangles.offer(firstTri);
  // Used for ballpivoting test
  if (choice == 5)
  {
    for (int i = 0; i < P.nv; i++)
      test_vertex.add(P.G[i]);

    for (int i = 0; i < Q.nv; i++)
      test_vertex.add(Q.G[i]);

    Triangle temp_triangle = new Triangle(Q.G[0], Q.G[1], Q.G[2]);
    vec AB = V(Q.G[0], Q.G[1]);
    vec AC = V(Q.G[0], Q.G[2]);

    temp_triangle.normal = U(cross(AB, AC));
    final_triangle.add(temp_triangle);

    pendingTriangles.offer(temp_triangle);
  }


  size_record = 1;
  count = 0;

  //radius of ball;
  ball_radius = CircleTri_radius(pendingTriangles.element());
  if (choice == 5)
    ball_radius += 2000;
  else
    ball_radius += test_radius;

  // used for deciding the correct normal vector(test only)
  absolute_center = CircleTri(pendingTriangles.element());
  absolute_center.z = (h_ceiling + h_floor) / 2.0f;
}
void BallPivot(ArrayList<pt> vertex)
{
  // Use ball pivoting algorithm gradually
  while (pendingTriangles.size() > 0 && count < size_record)
  {

    Triangle temp_tri = pendingTriangles.poll();
    final_triangle.add(temp_tri);

    Edge AB = new Edge(temp_tri.a, temp_tri.b);
    Edge BC = new Edge(temp_tri.b, temp_tri.c);
    Edge AC = new Edge(temp_tri.a, temp_tri.c);

    if (!inEdgeBuffer(visited_edge, AB))
      NextTriangle(temp_tri, AB, temp_tri.c, vertex, ball_radius, absolute_center,temp_tri.ai,temp_tri.bi);

    if (!inEdgeBuffer(visited_edge, BC))
      NextTriangle(temp_tri, BC, temp_tri.a, vertex, ball_radius, absolute_center,temp_tri.bi,temp_tri.ci);

    if (!inEdgeBuffer(visited_edge, AC))
      NextTriangle(temp_tri, AC, temp_tri.b, vertex, ball_radius, absolute_center,temp_tri.ai,temp_tri.ci);

    if (choice == 4)
      count++;
  }
  if (count >= size_record)
  {
    size_record = pendingTriangles.size();
    count = 0;
  }
  //Construct triangle mesh: Completed
  if (pendingTriangles.size() <= 0)
  {
    complete_flag = true;
  }
}



// Rotate the ball to next vertex . tri : the original triangle, e : the rotate axis(an edge of the triangle),third_vertex: tri - e, vertex: the vertices array, radius : radius of the ball, abscenter: haven't been used now
void NextTriangle(Triangle tri, Edge e, pt third_vertex, ArrayList<pt> vertex, float radius, pt abscenter,int ai_,int bi_)
{
  pt circle_center = CircleTri(tri);

  vec outside_vector;
  if (choice == 5)
    outside_vector = V(abscenter, circle_center);
  else
    outside_vector = tri.normal;

  pt center = SphereCenter(tri, radius, outside_vector);
  
  // min rotation angle of the ball and the record for the vertex index
  float min_angle =  2 * PI + 1;
  int record = -1;

  for (int i = 0; i < vertex.size(); i++)
  {
    //next point
    pt np = vertex.get(i);

    //This point is the vertex of the triangle,skip it
    if (IsTriangleVertex(tri, np))
      continue;
      
    // if the radius of the triangle is larger the sphere radius, skip it
    Triangle test_tri = new Triangle(e.a, e.b, np);
    test_tri.ai = ai_;
    test_tri.bi = bi_;
    test_tri.ci = i;
    float test_radius = CircleTri_radius(test_tri);
    
    if (test_radius > radius)
      continue;

    pt temp_circlecenter = CircleTri(test_tri);
    vec outside_vector2;
    if (choice == 5)
      outside_vector2 = V(abscenter, temp_circlecenter);
    else
      outside_vector2 = Triangle_normal(test_tri);

    //cirlce of a triangle with the edge and the new point
    pt np_center = SphereCenter(e.a, e.b, np, radius, outside_vector2);
    pt edge_mid = P(e.a, e.b);
    vec v1 = V(edge_mid, center);
    vec v2 = V(edge_mid, np_center);
    vec v3 = V(edge_mid, third_vertex);
    vec rotate_dir = U(cross(v3, v1));
    vec test_dir =  U(cross(v1, v2));
    
    float angle_helprer = dot(rotate_dir, test_dir);
    float rotate_angle = angle(v1, v2);

    //Because angle() return 0 - PI,so it needs to be changed into 0 - 2 * PI for this project
    if (angle_helprer < 0.001f)
      rotate_angle = 2 * PI - rotate_angle;

    if (rotate_angle < min_angle)
    {
      min_angle = rotate_angle;
      record = i;
    }
  }

  if (record != -1)
  {
    visited_edge.add(e);
    Edge e1 = new Edge(e.a, vertex.get(record));
    Edge e2 = new Edge(e.b, vertex.get(record));
    Triangle temp_tri = new Triangle(e.a, e.b, vertex.get(record));

    if (choice == 4)
    {
      temp_tri.ai = ai_;
      temp_tri.bi = bi_;
      temp_tri.ci = record;
      temp_tri.normal = Triangle_normal(temp_tri);

      
      precise_normal.get(temp_tri.ai).add(temp_tri.normal);
      precise_normal.get(temp_tri.bi).add(temp_tri.normal);
      precise_normal.get(temp_tri.ci).add(temp_tri.normal);
    }
      

    //if e1 or e2 hasn't been visited,the triangle is useful for ball pivoting.Otherwise,we just add it to final_triangle. 
    if (!inEdgeBuffer(visited_edge, e1) || !inEdgeBuffer(visited_edge, e2))
    {
      pendingTriangles.offer(temp_tri);
    } else
    {
      final_triangle.add(temp_tri);
    }
  }
}
//Test if the edge is in the edge buffer
boolean inEdgeBuffer(ArrayList<Edge> ebuffer, Edge e)
{
  boolean findflag = false;
  for (int i = 0; i < ebuffer.size(); i++)
  {
    if (SameEdge3D(ebuffer.get(i), e))
    {
      findflag = true;
      break;
    }
  }
  if (!findflag)
  {
    return false;
  } else
  {
    return true;
  }
}
boolean IsTriangleVertex(Triangle tri, pt vertex)
{
  float deviation = 0.001f;
  if (abs(tri.a.x - vertex.x) < deviation && abs(tri.a.y - vertex.y) < deviation && abs(tri.a.z - vertex.z) < deviation)
    return true;
  else if (abs(tri.b.x - vertex.x) < deviation && abs(tri.b.y - vertex.y) < deviation && abs(tri.b.z - vertex.z) < deviation)
    return true;
  else  if (abs(tri.c.x - vertex.x) < deviation && abs(tri.c.y - vertex.y) < deviation && abs(tri.c.z - vertex.z) < deviation)
    return true;

  return false;
}

void RenderTriangle(Triangle tri)
{

  if(choice == 4)
  {
  vec nora = getNormal(tri.ai);
  vec norb = getNormal(tri.bi);
  vec norc = getNormal(tri.ci);
  
    beginShape();
  normal(nora);
  vertex(tri.a);
  normal(norb);
  vertex(tri.b);
  normal(norc);
  vertex(tri.c);
  }
  else
  {
   beginShape();
  vertex(tri.a);
  vertex(tri.b);
  vertex(tri.c);
  }

  
  /*if(dot(nora,norb) < 0)
  println("Normal Error");*/
  //nora = Triangle_normal(tri);
  //norb = V(-1,nora);
  //vec nor = V(-1,tri.normal);
  




     
  endShape(CLOSE);
}

void Render_BallPivot()
{
  //println(vertices.size());
 // println(precise_normal.get(final_triangle.get(0).ai).size());
  //int t = 3;
 // int n = final_triangle.size() > t? t :final_triangle.size();
 // beginShape(TRIANGLES);
  for (int i = 0; i < final_triangle.size();i++)
  {
    RenderTriangle(final_triangle.get(i));
  }
 // endShape();
}

void buffer_reset()
{
  for(int i = 0; i < precise_normal.size();i++)
    precise_normal.get(i).clear();
  precise_normal.clear();
  vertices.clear();
  vertex_dir.clear();
  pendingTriangles.clear();
  complete_flag = false;
}

vec getNormal(int i)
{
  vec result = new vec(0,0,0);
  int n = precise_normal.get(i).size();
  for(int j = 0; j < n; j++)
  {
    result = A(result,U(precise_normal.get(i).get(j)));
  }
  result = U(result);
  
  if(norm(result) <= 0.001f)
  println("Error");
  
  
 // pt a = vertices.get(i);
 // pt b = P(a,10,result);
 // fill(red);
 // noStroke();
  
  //beam(a,b,rm);
 // stroke(1);
 // fill(green);
 // result = V(-1,result);
  return result;
  
  
}
vec Triangle_normal(Triangle tri)
{
  int ai = tri.ai;
  int bi = tri.bi;
  int ci = tri.ci;
  
  vec vecNormal = new vec();
  
  vec dira = vertex_dir.get(ai);
  vec dirb = vertex_dir.get(bi);
  vec dirc = vertex_dir.get(ci);
  vec dir = A(U(dira),U(dirb));
  dir = A(U(dirc),dir);
  dir = U(dir);
  
  
  
  pt A = tri.a;
  pt B = tri.b;
  pt C = tri.c;
  
  vec AB = V(A,B);
  vec AC = V(A,C);
  
  /*vec CA = V(C,A);
  vec CB = V(C,B);*/
  
  vecNormal = U(cross(AB,AC));
  
  if(dot(vecNormal,dir) < -0.01f)
  {
    vecNormal = V(-1,vecNormal);
    
    pt temp_pt = tri.b;
    tri.b = tri.c;
    tri.c = temp_pt;
    
    int temp_i = tri.bi;
    tri.bi = tri.ci;
    tri.ci = temp_i; 
  }
  
  return vecNormal;
}
/*boolean clockwise(Triangle tri)
{
  boolean flag = false;
  pt p1 = P(tri.a);
  pt p2 = P(tri.b);
  pt p3 = P(tri.c);
  
  vec v1 = V(p1,p2);
  vec v2 = V(p2,p3);
  vec v3 = V(p3,p1);
  
  int ai,bi,ci;
  
  ai = tri.ai;
  bi = tri.bi;
  ci = tri.ci;
  // A,B,C
  if(!flag && !cw(v1,v2,v3))
  {
    p1 = P(tri.a);
    p2 = P(tri.c);
    p3 = P(tri.b);
    
    ai = tri.ai;
    bi = tri.ci;
    ci = tri.bi;
  }
  else
  {
    flag = true;
  }
  // A,C,B
  v1 = V(p1,p2);
  v2 = V(p2,p3);
  v3 = V(p3,p1);
  
  if(!flag && !cw(v1,v2,v3))
  {
    p1 = P(tri.b);
    p2 = P(tri.a);
    p3 = P(tri.c);
    
    ai = tri.bi;
    bi = tri.ai;
    ci = tri.ci; 
  }
  else
  {
    flag = true;
  }
  
  // B,A,C
  v1 = V(p1,p2);
  v2 = V(p2,p3);
  v3 = V(p3,p1);
  
  if(!flag && !cw(v1,v2,v3))
  {
    p1 = P(tri.b);
    p2 = P(tri.c);
    p3 = P(tri.a);
    
    ai = tri.bi;
    bi = tri.ci;
    ci = tri.ai; 
  }
  else
  {
    flag = true;
  }
  
  // B,C,A
  v1 = V(p1,p2);
  v2 = V(p2,p3);
  v3 = V(p3,p1);
  
  if(!flag && !cw(v1,v2,v3))
  {
    p1 = P(tri.c);
    p2 = P(tri.a);
    p3 = P(tri.b);
    
    ai = tri.ci;
    bi = tri.ai;
    ci = tri.bi; 
  }
  else
  {
    flag = true;
  }
  
  // C,A,B
  v1 = V(p1,p2);
  v2 = V(p2,p3);
  v3 = V(p3,p1);
  
  if(!flag && !cw(v1,v2,v3))
  {
    p1 = P(tri.c);
    p2 = P(tri.b);
    p3 = P(tri.a);
    
    ai = tri.ci;
    bi = tri.bi;
    ci = tri.ai; 
  }
  else
  {
    flag = true;
  } 
  
  // C,B,A
  v1 = V(p1,p2);
  v2 = V(p2,p3);
  v3 = V(p3,p1);
  
  if(!flag && !cw(v1,v2,v3))
  {
    println("ClockWise Error");
  }
  else
  {
    flag = true;
  }
  
  if(flag)
  {
    
    println("ClockWise Succ");
    tri.a = p1;
    tri.b = p2;
    tri.c = p3;
    
    tri.ai = ai;
    tri.bi = bi;
    tri.ci = ci;
    return true;
  }
  else
  return false;
  
  
}*/