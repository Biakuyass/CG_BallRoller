import java.util.Queue;
import java.util.LinkedList;

//Problems Left:
//1.Calculate the correct normal for each triangle mesh(Used for Ball Pivoting)
//2.Calculate the correct normal for each vertex(For Rendering)
//3.Debug
int ball_number = 5;
int ball_circle = 10;
int tube_number = 25;
int tube_circle = 7;
float test_radius = 25;


ArrayList<Triangle> final_triangle = new ArrayList<Triangle> (); // Triangles Generated by Ball Pivoting
ArrayList<pt> test_vertex = new ArrayList<pt>(); // Used for test

ArrayList<Edge> visited_edge = new ArrayList<Edge>(); // Record the edges which have been visited
Queue<Triangle> pendingTriangles = new LinkedList<Triangle>(); // Store the triangles which haven't been dealt with

float ball_radius;
pt absolute_center;


void BallPivot_Clear()
{
  vertices.clear();
  final_triangle.clear();
  test_vertex.clear();
  visited_edge.clear();
  
}
void BallPivot_Init()
{

//final_triangle.add(firstTri);
// First Triangle to be 'Ball pivoted'

if(choice == 4)
  pendingTriangles.offer(firstTri);

// Used for test
if(choice == 5)
{
   for(int i = 0; i < P.nv; i++)
    test_vertex.add(P.G[i]);
    
    for(int i = 0; i < Q.nv; i++)
    test_vertex.add(Q.G[i]);
    
    Triangle temp_triangle = new Triangle(Q.G[0],Q.G[1],Q.G[2]);
    vec AB = V(Q.G[0],Q.G[1]);
    vec AC = V(Q.G[0],Q.G[2]);
    
    temp_triangle.normal = U(cross(AB,AC));
    final_triangle.add(temp_triangle);
    
    pendingTriangles.offer(temp_triangle);
}
  
    
    size_record = 1;
    count = 0;
    
  //radius of ball;
  ball_radius = CircleTri_radius(pendingTriangles.element());
  //println(ball_radius);
  if(choice == 5)
  ball_radius += 2000;
  else
  ball_radius += test_radius;
  
  // used for deciding the correct normal vector
  absolute_center = CircleTri(pendingTriangles.element());
  absolute_center.z = (h_ceiling + h_floor) / 2.0f;


    
}
void BallPivot(ArrayList<pt> vertex)
{

  while(pendingTriangles.size() > 0 && count < size_record)
  {
    
    Triangle temp_tri = pendingTriangles.poll();
    final_triangle.add(temp_tri);
    
    Edge AB = new Edge(temp_tri.a,temp_tri.b);
    Edge BC = new Edge(temp_tri.b,temp_tri.c);
    Edge AC = new Edge(temp_tri.a,temp_tri.c);
    
    if(!inEdgeBuffer(visited_edge,AB))
    NextTriangle(temp_tri,AB,temp_tri.c,vertex,ball_radius,absolute_center);
    
   if(!inEdgeBuffer(visited_edge,BC))
    NextTriangle(temp_tri,BC,temp_tri.a,vertex,ball_radius,absolute_center);
    
    if(!inEdgeBuffer(visited_edge,AC))
    NextTriangle(temp_tri,AC,temp_tri.b,vertex,ball_radius,absolute_center);
    
    if(choice == 4)
     count++;
  }
  if(count >= size_record)
  {
    size_record = pendingTriangles.size();
    count = 0;
  }
  if(pendingTriangles.size() <= 0)
  {
    complete_flag = true;
  }
  
 
}

void Render_BallPivot()
{
   for(int i = 0; i < final_triangle.size();i++)
  {
    RenderTriangle(final_triangle.get(i));
  }
}

// Rotate the ball to next vertex . tri : the original triangle, e : the rotate axis(an edge of the triangle),third_vertex: tri - e, vertex: the vertices array, radius : radius of the ball, abscenter: haven't been used now
void NextTriangle(Triangle tri,Edge e,pt third_vertex,ArrayList<pt> vertex,float radius,pt abscenter)
{
  pt circle_center = CircleTri(tri);
  
  vec outside_vector;
  if(choice == 5)
  outside_vector = V(abscenter,circle_center);
  else
  outside_vector = tri.normal;
  
  pt center = SphereCenter(tri,radius,outside_vector);
 // pt center = SphereCenter(tri,radius);
 // if(choice == 2)
  //center = SphereCenter(tri,radius,outside_vector);
  
  float min_angle =  2 * PI + 1;
  int record = -1;
  
  for(int i = 0; i < vertex.size(); i++)
  {
    
    //next point
    pt np = vertex.get(i);
    
    //This point is the vertex of the triangle,skip it
    if(IsTriangleVertex(tri,np))
    continue;
    
    Triangle test_tri = new Triangle(e.a,e.b,np);
    float test_radius = CircleTri_radius(test_tri);
    // if the radius of the triangle is larger the sphere radius, skip it
    if(test_radius > radius)
    continue;
    
    pt temp_circlecenter = CircleTri(test_tri);
    
    vec outside_vector2;
    if(choice == 5)
    outside_vector2 = V(abscenter,temp_circlecenter);
    else
    outside_vector2 = vertex_normal.get(i);
   
    //cirlce of a triangle consisting the edge and the new point
    pt np_center = SphereCenter(e.a,e.b,np,radius,outside_vector2);
   // pt np_center = SphereCenter(e.a,e.b,np,radius);
     // if(choice == 2)
   // np_center = SphereCenter(e.a,e.b,np,radius,outside_vector);*/
    
    
    pt edge_mid = P(e.a,e.b);
    
    vec v1 = V(edge_mid,center);
    vec v2 = V(edge_mid,np_center);
    vec v3 = V(edge_mid,third_vertex);
    
    vec rotate_dir = U(cross(v3,v1));
    vec test_dir =  U(cross(v1,v2));
    float angle_helprer = dot(rotate_dir,test_dir);

    float rotate_angle = angle(v1,v2);
    
    //Because angle() return 0 - PI,so it needs to be changed into 0 - 2 * PI for this project
    if(angle_helprer < 0.001f)
    rotate_angle = 2 * PI - rotate_angle;
    
    if(rotate_angle < min_angle)
    {
      min_angle = rotate_angle;
      record = i;
    }
    
  }
  
  if(record != -1)
  {
    visited_edge.add(e);
    Edge e1 = new Edge(e.a,vertex.get(record));
    Edge e2 = new Edge(e.b,vertex.get(record));
    Triangle temp_tri = new Triangle(e.a,e.b,vertex.get(record));
    temp_tri.normal = vertex_normal.get(record);
    //if e1 or e2 hasn't been visited,the triangle is useful for ball pivoting.Otherwise,we just add it to final_triangle. 
    if(!inEdgeBuffer(visited_edge,e1) || !inEdgeBuffer(visited_edge,e2))
    {
     pendingTriangles.offer(temp_tri);
    }
    else
    {
      final_triangle.add(temp_tri);
    }
  }
  
  
}

boolean inEdgeBuffer(ArrayList<Edge> ebuffer,Edge e)
{
  boolean findflag = false;
  for(int i = 0; i < ebuffer.size();i++)
  {
    if(SameEdge3D(ebuffer.get(i),e))
    {
         findflag = true;
         break;
    }
 
  }
  if(!findflag)
  {
    return false;
  }
  else
  {
    return true;
  }
}
boolean IsTriangleVertex(Triangle tri,pt vertex)
{
  float deviation = 0.001f;
  if(abs(tri.a.x - vertex.x) < deviation && abs(tri.a.y - vertex.y) < deviation && abs(tri.a.z - vertex.z) < deviation)
  return true;
  else if(abs(tri.b.x - vertex.x) < deviation && abs(tri.b.y - vertex.y) < deviation && abs(tri.b.z - vertex.z) < deviation)
  return true;
  else  if(abs(tri.c.x - vertex.x) < deviation && abs(tri.c.y - vertex.y) < deviation && abs(tri.c.z - vertex.z) < deviation)
  return true;
  
  return false;
}

void RenderTriangle(Triangle tri)
{
   beginShape();
     //   normal(normals.get(i).get(j));
   vertex(tri.a);
        
     //   normal(normals.get(i).get(next_j));
   vertex(tri.b);
        
     //   normal(normals.get(i + 1).get(next_j));
   vertex(tri.c);

  endShape();
  
}
void buffer_reset()
{
        vertices.clear();
      pendingTriangles.clear();
      complete_flag = false;
}